// Generated by CoffeeScript 1.6.1

/*
 MGA-1DSM incipit: getting captured in the jupiter system.
 
 @author: mmarcusx@gmail.com
*/


/*
    classes
*/


(function () {

    astrodynamics.mgaIncipit = (function () {

        function mgaIncipit(seq, tof, t0) {
            var i, invalid_tof, j, t, x, _i, _ref;
            if (seq.length < 1) {
                throw 'ValueError: sequence needs at least one body';
            }
            if (tof.length !== seq.length) {
                throw 'ValueError: tof sequence has the wrong length';
            }
            invalid_tof = (function () {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = tof.length; _i < _len; _i++) {
                    t = tof[_i];
                    if (t.length !== 2) {
                        _results.push(t);
                    }
                }
                return _results;
            })();
            if (invalid_tof.length !== 0) {
                throw 'ValueError: tof sequence must consist of 2-tuples';
            }
            if (t0.length !== 2) {
                throw 'ValueError: starting epoch needs to be a 2 tuple';
            }
            this.seq = seq;
            this.tof = tof;
            this.t0 = t0;
            this.dim = 4 * seq.length;
            this.bounds = (function () {
                var _i, _ref, _results;
                _results = [];
                for (x = _i = 1, _ref = this.dim; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
                    _results.push([0, 0]);
                }
                return _results;
            }).call(this);
            this.bounds[0] = t0;
            this.bounds[1] = [0, 1];
            this.bounds[2] = [0, 1];
            this.bounds[3] = tof[0];
            for (i = _i = 4, _ref = this.bounds.length; 4 <= _ref ? _i < _ref : _i > _ref; i = 4 <= _ref ? ++_i : --_i) {
                j = Math.floor(i / 4);
                if (i % 4 === 0) {
                    this.bounds[i] = [-2 * Math.PI, 2 * Math.PI];
                } else if (i % 4 === 1) {
                    this.bounds[i] = [seq[j].safeRadius / seq[j].radius, (seq[j].radius + 2000000) / seq[j].radius];
                } else if (i % 4 === 2) {
                    this.bounds[i] = [1e-5, 1.0 - 1e-5];
                } else if (i % 4 === 3) {
                    this.bounds[i] = tof[j + 1];
                }
            }
        }

        mgaIncipit.prototype.set_beta = function (x) {
            var i, j, low, up, _i, _ref;
            if (x.length !== this.seq.length - 1) {
                throw 'ValueError: New bounds did not match problem dimension.';
            }
            for (i = _i = 4, _ref = this.bounds.length; 4 <= _ref ? _i < _ref : _i > _ref; i = 4 <= _ref ? ++_i : --_i) {
                if (i % 4 === 0) {
                    j = Math.floor(i / 4);
                    low = -2 * Math.PI > x[j].lower ? -2 * Math.PI : x[j].lower;
                    up = 2 * Math.PI < x[j].upper ? 2 * Math.PI : x[j].upper;
                    this.bounds[i] = [low, up];
                }
            }
            return this.bounds;
        };

        mgaIncipit.prototype.set_rp = function (x) {
            var i, j, low, maxhigh, minlow, up, _i, _ref;
            if (x.length !== this.seq.length - 1) {
                throw 'ValueError: New bounds did not match problem dimension.';
            }
            for (i = _i = 4, _ref = this.bounds.length; 4 <= _ref ? _i < _ref : _i > _ref; i = 4 <= _ref ? ++_i : --_i) {
                if (i % 4 === 1) {
                    j = Math.floor(i / 4);
                    minlow = this.seq[j].safeRadius / this.seq[j].radius;
                    maxhigh = (this.seq[j].radius + 2000000) / this.seq[j].radius;
                    low = minlow > x[j].lower ? minlow : x[j].lower;
                    up = maxhigh < x[j].upper ? maxhigh : x[j].upper;
                    this.bounds[i] = [low, up];
                }
            }
            return this.bounds;
        };

        mgaIncipit.prototype.set_tof = function (x) {
            var i, _i, _ref;
            if (x.length !== this.seq.length) {
                throw 'ValueError: New bounds did not match problem dimension.';
            }
            for (i = _i = 0, _ref = this.bounds.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                if (i % 4 === 3) {
                    this.bounds[i] = x[Math.floor(i / 4)];
                }
            }
            return this.bounds;
        };

        mgaIncipit.prototype.objfun = function (x) {
            var T, d, dt, dv, eph_m, i, lp, phi, pl, planet, r, t_P, theta, v_beg_l, v_end_l, v_out, _i, _ref;
            T = (function () {
                var _i, _ref, _results;
                _results = [];
                for (i = _i = 0, _ref = this.dim; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                    if ((i + 1) % 4 === 0) {
                        _results.push(x[i]);
                    }
                }
                return _results;
            }).call(this);
            t_P = (function () {
                var _i, _len, _ref, _results;
                _ref = this.seq;
                _results = [];
                for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                    planet = _ref[i];
                    _results.push(x[0] + arr_sum(T.slice(0, i + 1)));
                }
                return _results;
            }).call(this);
            eph_m = (function () {
                var _i, _len, _ref, _results;
                _ref = this.seq;
                _results = [];
                for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                    planet = _ref[i];
                    _results.push(astrodynamics.planetEphemerides(t_P[i], planet));
                }
                return _results;
            }).call(this);
            theta = 2 * Math.PI * x[1];
            phi = Math.acos(2 * x[2] - 1) - (Math.PI / 2);
            r = [Math.cos(phi) * Math.sin(theta), Math.cos(phi) * Math.cos(theta), Math.sin(phi)];
            r = (function () {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = r.length; _i < _len; _i++) {
                    d = r[_i];
                    _results.push(R_JUP * 1000 * d);
                }
                return _results;
            })();
            lp = astrodynamics.lambertProblem(r, eph_m[0].r, T[0] * constants.DAY2SEC, false);
            v_end_l = lp.v2;
            v_beg_l = lp.v1;
            dv = [Math.abs(v_beg_l.normEuclid() - 3400)];
            for (i = _i = 1, _ref = this.seq.length; 1 <= _ref ? _i < _ref : _i > _ref; i = 1 <= _ref ? ++_i : --_i) {
                v_out = astrodynamics.fbProp(v_end_l, eph_m[i - 1].v, x[4 * i], x[1 + 4 * i] * this.seq[i - 1].radius, this.seq[i - 1].mu);
                pl = astrodynamics.propagateLagrangian(eph_m[i - 1].r, v_out, x[4 * i + 2] * T[i] * constants.DAY2SEC, constants.MU_JUPITER);
                dt = (1 - x[4 * i + 2]) * T[i] * DAY2SEC;
                lp = astrodynamics.lambertProblem(pl.r, eph_m[i].r, dt, false);
                v_end_l = lp.v2;
                v_beg_l = lp.v1;
                dv.push(v_beg_l.clone().sub(pl.v).normEuclid());
            }
            return arr_sum(dv);
        };

        mgaIncipit.prototype.feasible = function (x) {
            var elem, i, _i, _len;
            for (i = _i = 0, _len = x.length; _i < _len; i = ++_i) {
                elem = x[i];
                if (!((this.bounds[i][0] <= elem && elem <= this.bounds[i][1]))) {
                    return false;
                }
            }
            return true;
        };

        return mgaIncipit;

    })();

}).call(this);