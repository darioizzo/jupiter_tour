// Generated by CoffeeScript 1.4.0

/*
 Coffee script implementation of jde based on
	Brest, J., V. Zumer, and M. Sepesy Maucec. 
	"Self-adaptive differential evolution algorithm in constrained real-parameter optimization." 
	Evolutionary Computation, 2006. CEC 2006. IEEE Congress on. IEEE, 2006. 
 
 @author: mmarcusx@gmail.com
*/


/*
	classes
*/


(function() {
  var arr_add, arr_scalar, arr_sum, championidx, choice, individual, jde, random_int, random_real, rastrigin, takeout;

  rastrigin = (function() {

    function rastrigin(dim) {
      var x;
      this.bounds = (function() {
        var _i, _results;
        _results = [];
        for (x = _i = 1; 1 <= dim ? _i <= dim : _i >= dim; x = 1 <= dim ? ++_i : --_i) {
          _results.push([-5.12, 5.12]);
        }
        return _results;
      })();
      this.dim = dim;
    }

    rastrigin.prototype.objfun = function(x) {
      var omega, s, xi;
      omega = 2.0 * Math.PI;
      s = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = x.length; _i < _len; _i++) {
          xi = x[_i];
          _results.push(xi * xi - 10.0 * Math.cos(omega * xi));
        }
        return _results;
      })();
      return arr_sum(s) + this.dim * 10;
    };

    rastrigin.prototype.feasible = function(x) {
      var elem, i, _i, _len;
      for (i = _i = 0, _len = x.length; _i < _len; i = ++_i) {
        elem = x[i];
        if (!((this.bounds[i][0] <= elem && elem <= this.bounds[i][1]))) {
          return false;
        }
      }
      return true;
    };

    return rastrigin;

  })();

  individual = (function() {

    function individual(prob) {
      var b;
      this.x = (function() {
        var _i, _len, _ref, _results;
        _ref = prob.bounds;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          b = _ref[_i];
          _results.push(Math.random() * (b[1] - b[0]) + b[0]);
        }
        return _results;
      })();
      this.f = prob.objfun(this.x);
    }

    return individual;

  })();

  jde = (function() {

    function jde(variant) {
      if (variant == null) {
        variant = 2;
      }
      this.variant = variant;
    }

    jde.prototype.evolve = function(pop, prob, gen) {
      var L, best_idx, cr, f, i, ind, ind1_chr, ind2_chr, ind3_chr, j, k, mutant, n, new_chr, new_ind, new_pop, pop_cr, pop_f, r, sure_cross_idx, tmp_pop, v, _i, _j, _k, _l, _len, _len1, _len2, _ref;
      if (gen === 0) {
        return pop;
      }
      pop_f = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = pop.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(Math.random() * 0.9 + 0.1);
        }
        return _results;
      })();
      pop_cr = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = pop.length; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push(Math.random());
        }
        return _results;
      })();
      for (i = _i = 1; 1 <= gen ? _i <= gen : _i >= gen; i = 1 <= gen ? ++_i : --_i) {
        best_idx = championidx(pop);
        new_pop = [];
        for (j = _j = 0, _len = pop.length; _j < _len; j = ++_j) {
          ind = pop[j];
          tmp_pop = takeout(pop, j);
          r = choice(tmp_pop, 3);
          ind1_chr = tmp_pop[r[0]].x;
          ind2_chr = tmp_pop[r[1]].x;
          ind3_chr = tmp_pop[r[2]].x;
          f = Math.random() >= 0.9 ? Math.random() * 0.9 + 0.1 : pop_f[j];
          cr = Math.random() >= 0.9 ? Math.random() : pop_cr[j];
          mutant = arr_add(ind1_chr, arr_scalar(arr_add(ind2_chr, arr_scalar(ind3_chr, -1.0)), f));
          for (k = _k = 0, _len1 = mutant.length; _k < _len1; k = ++_k) {
            v = mutant[k];
            if (!((prob.bounds[k][0] <= v && v <= prob.bounds[k][1]))) {
              mutant[k] = random_real(prob.bounds[k][0], prob.bounds[k][1]);
            }
          }
          if (this.variant === 1) {
            new_chr = [];
            sure_cross_idx = random_int(0, prob.dim - 1);
            _ref = ind.x;
            for (k = _l = 0, _len2 = _ref.length; _l < _len2; k = ++_l) {
              v = _ref[k];
              if ((Math.random() <= cr) || (k === sure_cross_idx)) {
                new_chr.push(mutant[k]);
              } else {
                new_chr.push(ind.x[k]);
              }
            }
          } else if (this.variant === 2) {
            n = random_int(0, prob.dim - 1);
            new_chr = ind.x.slice(0);
            L = 0;
            while (true) {
              new_chr[n] = mutant[n];
              n = (n + 1) % prob.dim;
              ++L;
              if ((Math.random() >= cr) || (L >= prob.dim)) {
                break;
              }
            }
          } else {
            alert("variant unknown, evolution aborted!");
            return pop;
          }
          new_ind = {
            x: new_chr,
            f: prob.objfun(new_chr)
          };
          if (new_ind.f < ind.f) {
            new_pop.push(new_ind);
            pop_f[j] = f;
            pop_cr[j] = cr;
          } else {
            new_pop.push(ind);
          }
        }
        if (pop[best_idx].f > new_pop[championidx(new_pop)].f) {
          console.log('generation ' + i + ' improved ' + pop[best_idx].f + ' --> ' + new_pop[championidx(new_pop)].f);
        }
        pop = new_pop;
      }
      return pop;
    };

    return jde;

  })();

  /* 
  	helper functions
  */


  championidx = function(pop) {
    var idx, min_idx, _i, _ref;
    min_idx = 0;
    for (idx = _i = 1, _ref = pop.length; 1 <= _ref ? _i < _ref : _i > _ref; idx = 1 <= _ref ? ++_i : --_i) {
      if (pop[idx].f < pop[min_idx].f) {
        min_idx = idx;
      }
    }
    return min_idx;
  };

  random_real = function(lower, upper) {
    var start, _ref, _ref1;
    if (upper == null) {
      upper = 0;
    }
    start = Math.random();
    if (!(lower != null)) {
      _ref = [0, lower], lower = _ref[0], upper = _ref[1];
    }
    if (lower > upper) {
      _ref1 = [upper, lower], lower = _ref1[0], upper = _ref1[1];
    }
    return start * (upper - lower) + lower;
  };

  random_int = function(lower, upper) {
    var start, _ref, _ref1;
    if (upper == null) {
      upper = 0;
    }
    start = Math.random();
    if (!(lower != null)) {
      _ref = [0, lower], lower = _ref[0], upper = _ref[1];
    }
    if (lower > upper) {
      _ref1 = [upper, lower], lower = _ref1[0], upper = _ref1[1];
    }
    return Math.floor(start * (upper - lower + 1) + lower);
  };

  choice = function(arr, c) {
    var i, idx, n, _i, _j, _ref, _ref1, _results;
    n = (function() {
      _results = [];
      for (var _i = 0, _ref = arr.length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    for (i = _j = 0; 0 <= c ? _j < c : _j > c; i = 0 <= c ? ++_j : --_j) {
      idx = random_int(i, arr.length - 1);
      _ref1 = [n[idx], n[i]], n[i] = _ref1[0], n[idx] = _ref1[1];
    }
    return n.slice(0, c);
  };

  takeout = function(arr, idx) {
    return arr.slice(0, idx).concat(arr.slice(idx + 1));
  };

  arr_add = function(arr1, arr2) {
    var arr3, i, _i, _ref;
    arr3 = [];
    for (i = _i = 0, _ref = arr1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      arr3.push(arr1[i] + arr2[i]);
    }
    return arr3;
  };

  arr_scalar = function(arr, scalar) {
    var i, x, _i, _len;
    for (i = _i = 0, _len = arr.length; _i < _len; i = ++_i) {
      x = arr[i];
      arr[i] = x * scalar;
    }
    return arr;
  };

  arr_sum = function(arr) {
    var s, x, _i, _len;
    s = 0.0;
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      x = arr[_i];
      s += x;
    }
    return s;
  };

  /* 
  	main namespace
  */


  this.jdebox = {
    gen_rastrigin: function() {
      var dim, v;
      v = document.getElementById('dimfield').value;
      if ((1 <= v && v <= 99)) {
        dim = v;
      } else {
        dim = 10;
        document.getElementById('dimfield').value = 10;
      }
      this.prob = new rastrigin(dim);
      return document.getElementById('popbutton').disabled = false;
    },
    gen_pop: function() {
      var i, p, v;
      v = document.getElementById('popfield').value;
      if ((8 <= v && v <= 999)) {
        p = v;
      } else {
        p = 100;
        document.getElementById('popfield').value = 100;
      }
      this.alg = new jde();
      this.pop = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 1; 1 <= p ? _i <= p : _i >= p; i = 1 <= p ? ++_i : --_i) {
          _results.push(new individual(this.prob));
        }
        return _results;
      }).call(this);
      return document.getElementById('evolvebutton').disabled = false;
    },
    evolve: function() {
      var k, s, v, _i, _len, _ref;
      v = parseInt(document.getElementById('genfield').value);
      if ((1 <= v && v <= 5000)) {
        document.getElementById('evolvebutton').disabled = true;
        this.pop = this.alg.evolve(this.pop, this.prob, v);
        document.getElementById('evolvebutton').disabled = false;
        s = '<p>current fitness: ' + this.pop[championidx(this.pop)].f + '<p/>';
        s += 'decision vector: <ul>';
        _ref = this.pop[championidx(this.pop)].x;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          k = _ref[_i];
          s += '<li>' + k + '</li>';
        }
        s += '</ul>';
        return document.getElementById('output').innerHTML = s;
      } else {
        return alert('Enter a number of generations between 1 and 5000');
      }
    }
  };

}).call(this);
