// Generated by CoffeeScript 1.6.1

/*
 MGA-1DSM part: jumping from one moon to another
 
 @author: mmarcusx@gmail.com
*/


/*
    classes
*/


(function() {

  core.mga_part = (function() {

    function mga_part(seq, tof, t0, v_inf) {
      var i, invalid_tof, j, t, x, _i, _ref;
      if (seq.length < 2) {
        throw 'ValueError: sequence needs at least two bodies';
      }
      if (tof.length !== (seq.length - 1)) {
        throw 'ValueError: tof sequence has the wrong length';
      }
      invalid_tof = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = tof.length; _i < _len; _i++) {
          t = tof[_i];
          if (t.length !== 2) {
            _results.push(t);
          }
        }
        return _results;
      })();
      if (invalid_tof.length !== 0) {
        throw 'ValueError: tof sequence must consist of 2-tuples';
      }
      this.seq = seq;
      this.tof = tof;
      this.t0 = t0;
      this.v_inf = v_inf;
      this.dim = 4 * (seq.length - 1);
      this.bounds = (function() {
        var _i, _ref, _results;
        _results = [];
        for (x = _i = 1, _ref = this.dim; 1 <= _ref ? _i <= _ref : _i >= _ref; x = 1 <= _ref ? ++_i : --_i) {
          _results.push([0, 0]);
        }
        return _results;
      }).call(this);
      for (i = _i = 0, _ref = this.bounds.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        j = Math.floor(i / 4);
        if (i % 4 === 0) {
          this.bounds[i] = [-2 * Math.PI, 2 * Math.PI];
        } else if (i % 4 === 1) {
          this.bounds[i] = [seq[j].safeRadius / seq[j].radius, (seq[j].radius + 2000000) / seq[j].radius];
        } else if (i % 4 === 2) {
          this.bounds[i] = [1e-5, 1.0 - 1e-5];
        } else if (i % 4 === 3) {
          this.bounds[i] = tof[j];
        }
      }
    }

    mga_part.prototype.set_beta = function(x) {
      var i, j, low, up, _i, _ref;
      if (x.length !== this.seq.length - 1) {
        throw 'ValueError: New bounds did not match problem dimension. Give one 2-tuple per leg!';
      }
      for (i = _i = 0, _ref = this.bounds.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i % 4 === 0) {
          j = Math.floor(i / 4);
          low = -2 * Math.PI > x[j].lower ? -2 * Math.PI : x[j].lower;
          up = 2 * Math.PI < x[j].upper ? 2 * Math.PI : x[j].upper;
          this.bounds[i] = [low, up];
        }
      }
      return this.bounds;
    };

    mga_part.prototype.set_rp = function(x) {
      var i, j, low, maxhigh, minlow, up, _i, _ref;
      if (x.length !== this.seq.length - 1) {
        throw 'ValueError: New bounds did not match problem dimension. Give one 2-tuple per leg!';
      }
      for (i = _i = 0, _ref = this.bounds.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i % 4 === 1) {
          j = Math.floor(i / 4);
          minlow = this.seq[j].safeRadius / this.seq[j].radius;
          maxhigh = (this.seq[j].radius + 2000000) / this.seq[j].radius;
          low = minlow > x[j].lower ? minlow : x[j].lower;
          up = maxhigh < x[j].upper ? maxhigh : x[j].upper;
          this.bounds[i] = [low, up];
        }
      }
      return this.bounds;
    };

    mga_part.prototype.set_tof = function(x) {
      var i, _i, _ref;
      if (x.length !== this.seq.length - 1) {
        throw 'ValueError: New bounds did not match problem dimension. Give one 2-tuple per leg!';
      }
      for (i = _i = 0, _ref = this.bounds.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (i % 4 === 3) {
          this.bounds[i] = x[Math.floor(i / 4)];
        }
      }
      return this.bounds;
    };

    mga_part.prototype.objfun = function(x) {
      var T, dt, dv, eph_m, i, lp, pl, planet, t_P, v_beg_l, v_end_l, v_out, _i, _len, _ref;
      T = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this.dim; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          if ((i + 1) % 4 === 0) {
            _results.push(x[i]);
          }
        }
        return _results;
      }).call(this);
      t_P = (function() {
        var _i, _len, _ref, _results;
        _ref = this.seq;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          planet = _ref[i];
          _results.push(this.t0 + arr_sum(T.slice(0, i)));
        }
        return _results;
      }).call(this);
      eph_m = (function() {
        var _i, _len, _ref, _results;
        _ref = this.seq;
        _results = [];
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          planet = _ref[i];
          _results.push(core.planet_ephemerides(t_P[i], planet));
        }
        return _results;
      }).call(this);
      v_end_l = arr_add(this.v_inf, eph_m[0].v);
      dv = [];
      _ref = this.seq.slice(0, this.seq.length - 1);
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        planet = _ref[i];
        v_out = core.fb_prop(v_end_l, eph_m[i].v, x[i * 4], x[i * 4 + 1] * planet.radius, planet.mu);
        pl = core.propagate_lagrangian(eph_m[i].r, v_out, x[i * 4 + 2] * x[i * 4 + 3] * DAY2SEC, MU_JUP);
        dt = (1 - x[i * 4 + 2]) * x[i * 4 + 3] * DAY2SEC;
        lp = core.lambert_problem(pl.r, eph_m[i + 1].r, dt, false);
        v_end_l = lp.v2;
        v_beg_l = lp.v1;
        dv.push(core.magnitude(core.subtraction(v_beg_l, pl.v)));
      }
      return arr_sum(dv);
    };

    mga_part.prototype.feasible = function(x) {
      var elem, i, _i, _len;
      for (i = _i = 0, _len = x.length; _i < _len; i = ++_i) {
        elem = x[i];
        if (!((this.bounds[i][0] <= elem && elem <= this.bounds[i][1]))) {
          return false;
        }
      }
      return true;
    };

    return mga_part;

  })();

  /*
      main namespace
  */


  test.gen_mga_part = function() {
    var prob;
    console.log('generate mga_part');
    try {
      prob = new core.mga_part([europa, europa, europa], [[1, 50], [1, 50]], 62544.0, [1500.0, 350, 145.0]);
    } catch (error) {
      alert(error);
    }
    document.getElementById('popbutton').disabled = false;
    return prob;
  };

}).call(this);
